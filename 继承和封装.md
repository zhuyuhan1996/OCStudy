- 在类方法中不能直接访问属性，也不能用self直接调用其他的对象方法，在类方法的内部创建1个对象，访问这个对象的成员。在对象方法中可以直接使用类名来调用类方法。
- 对象方法和类方法要区别开，+开头为类方法，-开头为对象方法。
- NSString是一个类。没有指针指向的对象为一个匿名对象[NSString new]，匿名对象只能使用一次。使用场景为：一个对象只使用一次之后不会再次使用就可以使用匿名对象。
- 属性的封装。1、setter和getter的规范，2、封装规范，只要这个属性需要被外界访问，哪怕在赋值的时候没有任何的逻辑验证，我们都应该为这个属性封装一个getter和setter。3、只读和只写。
- 类与类之间的关系：组合：一个类是由其他多个类组合而成的、依赖、关联：一个类拥有另外一个对象、继承
---------------------------------------------
- 框架中有很多的类和函数，提供了一些数据
- Xcode文档详细的描述了这些信息。需要单独的安装
---------------------------------------------
static
- 在C语言中修饰局部变量，修饰全局变量，修饰函数
- 在OC中，static不能修饰属性，也不能修饰方法，可以修饰方法中的局部变量。 如果方法中的局部变量被static 修饰，那么这个变量就会变成静态变量。  存储在常量区，当方法执行完毕时不会回收。下次再执行这个方法的时候，直接使用而不会再声明了。
- 如果方法的返回值是当前类的对象，那么方法的返回值就写instance type 
----------------------------------------------
self 关键字
- 在方法的内部可以定义1个和属性名相同的局部变量。这个时候如果在方法中访问这个同名变量，访问的为局部变量。
- self:和this关键字有点像，可以在对象方法和类方法中使用，self是一个指针，在对象方法中self指向当前对象，在类方法中指向当前类。
- 谁调用方法谁就是当前对象，在对象方法中，self指向当前对象，可以访问当前对象的属性和当前对象的方法。
- 可以用self显示访问当前对象的属性。self->属性，代表访问的是当前对象的属性。可以使用self来调用当前对象的其他的对象方法。
- 对象方法当中必须使用self的场景：如果在方法中存在和属性同名的局部变量，你如果想要访问同名的局部变量，直接写就可以了。你如果想要访问当前对象的同名属性，必须使用self。
- 在对象方法当中，如果要调用当前对象的其他的对象方法，必须使用self。
- 在方法当中不存在和属性同名的局部变量，若果这个时候访问当前对象属性，用不用self效果都一样。
- 在类方法中使用self，当类第一次被访问的时候，会将类的代码存储在代码区，代码区中用来存储类的空间也有一个地址。
- 在类方法中，self为一个指针，指向当前这个类在代码段中的地址。self在类代码当中就相当于当前这个类。
- 取到类在代码段中的地址的方式：调试查看对象的isa指针；在类方法中输出self值；调用p1对象的class方法；调用类的类方法class，就可以返回代码段的地址。
- 对象方法可以声明多次，但是只会认为有1次，对象方法之间是不能重名的，类方法之间也是不可以重名的。对象方法和类方法是可以重名的。通过类名调用的就是类方法，通过对象名调用的就是对象方法。
- 可以在类方法中使用self来显示的调用本类的其他类方法。
- 在对象方法昂中，self代表的就是当前对象，可以通过self访问当前对象。但是不能在类中使用self调用类方法。在类方法中，self代表当前这个类。所以可以通过self调用当前类的其他方法，但是不能访问对象的属性。
--------------------------------------------
继承
- 多个类具有相同的成员，就可以使用继承的方式。
- 继承的目的：拥有父类的所有成员，不用自己定义。语法：@interface 类名：父类。
- 对象和对象之间无关。
- 如果有一个成员不是所有子类都拥有，就不应该定义在父类之中。父类中只定义所有的子类中都拥有的属性。
- OC中继承有单根性，有且只能有一个父类，不能有多个父类。传递性：A类从B类继承，B类从C类继承，那么A类就有B，C类的成员。
- NSObject类是Foundation框架中的类，在这个类中有一个类方法new，这个方法是用来创建对象的，方法的返回值是创建这个对象的指针。如果要创建对象，就必须需要这个new方法。
- 在NSObject类中，还定义了一个属性，这个属性叫isa指针，所以每一个子类对象中都有一个叫做isa的指针，NSObject类是OC中所有类的父类。
- 子类中不能存在和父类同名的属性。
- super关键字：1、可以用在类方法和对象方法之中；2、在对象方法中，可以使用super关键字调用当前对象从父类继承过来的对象方法；3、在类方法中，super关键字可以调用从父类继承过来的类方法：父类中的类方法可以i通过父类名调用，也可以通过子类名调用。在子类的类方法当中，可以使用super关键字调用父类的类方法。super 只能用来调用父类的对象方法或者类方法，不能用来访问属性。
- super方法特指从父类继承过来的。是指当前类或者对象的方法从父类继承而来。
---------------------------------------------
- 访问修饰符：用来修饰属性，可以限定对象的书香在那一段范围之中访问。@protect修饰的属性只能在本类和子类中访问。@package修饰的属性可以在当前框架中访问。
- 不为属性制定访问修饰符，默认的就是@public。
- 子类仍然可以继承父类的私有属性。只不过在子类中无法直接去访问父类的私有属性。如果父类中有一个方法在为属性赋值或者取值。
- 访问修饰符的作用域为从写访问修饰符的地方开始，直到遇到另一个访问修饰符为止。
- 访问修饰符只能用来修饰属性，不能用来修饰方法。
- 属性写在@implementation的大括号中，这样就可以完全变成 私有类型，外界无法访问也无法看到。
- 对于方法，只写实现不写声明，就可以只在本类的其他方法中进行调用，不能在外界调用。
-------------------------------------------------
多态
- 里氏替换原则---LSP：子类可以替换父类的位置，并且程序的功能不受影响。父类指针迫切的需求要一个父类对象，而且我们给了一个子类对象，这是完全没有问题的，因为子类就是一个父类嘛。因为父类当中拥有的成员，子类都有，所以不会影响程序的功能。
- 当一个父类指针指向一个子类对象的时候，这里就有里氏替换原则。
- 作用：1、1个指针中不仅可以存储本类对象的地址，还可以存储子类对象的地址。2、如果一个指针是NSObject指针，可以存储任意OC对象的地址。3、如果一个数组的元素类型为一个OC指针类型，那么这个数组不仅可以存储本类对象还可以存储子类对象。
- 当一个父类指针指向子类对象的时候，通过这个父类指针只能调用子类对象当中的父类成员。子类独有的成员无法访问。
- 子类从父类继承，那么子类就继承了父类的方法，就意味着子类拥有了这个方法，虽然拥有了这个方式，与父类的实现不一样，这个时候就要方法的重载。直接在实现出重写方法就OK了。
- 当一个父类指针指向一个子类对象时，通过这个父类指针调用的方法在子类对象中重写了，调用的就是子类重写的方法。
- 同一个行为对于不同的事物具有完全不同的表现形式。同一个行为具备多种形态。
- %p打印的是指针的对象的值，%@打印的是指针指向的对象。如果我们使用%@打印一个对象，输出的格式为<对象所属的类名：对象的地址>，调用传入得对象的description方法，拿到这个方法的返回值，返回值为一个字符串，并输出。 
- 每一个OC对象都有description方法。可以对其进行重写。

1、本类对象作为本类方法的参数

2、异常处理
- 一般情况下，错误指的是源代码不符合语法规范，程序无法编译。
- bug：程序可以编译、链接、执行。但是程序执行的结果并不是我们所预想的那样。通过调试寻找发生bug的原因。
- 异常：程序可以编译、链接、执行，当程序执行时，处于某种特定条件下，程序就会终止，会造成程序的崩溃。
- 如何处理异常：目的在于让程序在执行的时候发生异常不崩溃，继续往下执行。语法：
> @try
> {
>
> }
>
> @catch(NSException *ex)
> {
>
> }
> @finally
> {
> }

- 将有可能发生异常的代码放在@try中，如果@try中的代码在执行的时候，发生了异常，不会崩溃，跳转到@catch中执行里面的代码，当@catch的代码完毕之后，结束@try...@catch往下执行。如果@try中的代码在执行时，没有异常，就会略过@catch往下执行。
- @catch中的代码只有在@try的代码发生异常的时候才会执行，所以，@catch一般写处理异常的代码。
- @catch的参数NSException *ex通过%@可以打印出ex指向的对象的值，显示发生异常的原因。
- @finally无论发生异常都会执行
- @try...@catch并不是所有的运行时错误都可以处理的。避免异常最常用的方式还是逻辑判断。

3、类方法的声明和调用
- 对象方法：之前学习的方法就叫对象方法，想要调用对象方法就要先创建对象
- 类方法：调用不依赖对象，如果要调用类方法，不需要创建对象，直接通过类名来调用。
- 声明：
> +(返回值类型) 方法名;
- 调用：对象方法，先创建对象，通过对象名来调用，类方法不需要通过对象名调用，所以如果要调用类方法不需要创建对象，而是直接使用类名来调用。
- 类方法的特点：节约空间，因为类方法的调用不需要创建对象，这样就节约了空间。提高效率，调用类方法不需要拐弯抹角，直接执行类中的类方法。
- 在类方法中不能直接访问属性。属性是在对象创建的时候跟着对象一起创建，类第一次被访问的时候会做类加载。类方法在执行的时候可能还没有创建对象。
- 在类方法中也不能通过self调用当前类的其他对象方法。在对象方法当中可以直接调用类方法。