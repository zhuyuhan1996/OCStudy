内存分配
- 子类对象当中有自己的属性和所有父类的属性，子类有一个isa指针指向自己的父类。一直指向NSObject。
----
结构体与类的区别
- 都可以将多个数据封装为一个整体。
- 1、结构体只能封装数据，类可以封装数据和行为。
- 2、结构体变量存储在栈空间，而对象分配在堆空间。栈的特点：空间相对较小，但是访问效率更高；堆的特点：空间相对较大，当时访问效率相对较低。如果属性较少，可以使用结构体进行定义，当属性较多时，建议使用类进行定义。
- 3、结构体是值赋值的，类是引用赋值。
----
类的存储
- 栈：局部变量、堆：OC对象以及申请的空间alloc、BSS段：未初始化的全局变量和静态变量、数据段：常量数据、代码段：用来存储代码的。当类第一次被访问的时候，就会加载到代码段存储起来。
- 类一旦被加载后，是不会被回收的。存储类的Class对象我们叫做类对象，用来存储类的一个对象。
- 调用类的类方法 class 就可以得到存储类的类对象的地址。调用对象的对象方法 class 就可以得到这个对象存储该对象类的地址。对象中的isa的值，就是代码段中存储类的类对象的地址。注意：在声明Class指针的时候，不需要加*，因为在typedef的时候已经加了。
- 拿到存储类的类对象,c1对象就是person类。使用类对象，只能调用类的类方法。可以使用类的类对象调用类方法。
```
Class c1 = [Person class]
```
----
SEL
- 全称select 选择器。是一个数据类型。在内存中申请空间存储数据。SEL其实是一个类。SEL对象是用来存储一个方法的。
- 先创建一个SEL对象，将方法的信息存储在这个SEL对象之中。再将这个SEL对象作为这个类对象的属性。
- SEL是一个typedef类型的，在声明SEL的时候，不需要加*。取到存储方法的SEL对象。SEL s1= @selector(方法名)
- 先拿到存储sayHi方法的SEL对象，SEL消息，将该消息发送给p1对象，这个时候p1对象接收到这个SEL消息后，就知道要调用方法，根据对象的isa指针找到存储类的类对象。找到这个对象后，去类对象中搜索是否有数据相匹配。
- OC最重要的一个机制：消息机制。调用方法的本质就是为对象发送SEL消息。
- 手动为对象发送SEL消息，先得到方法的SEL消息，将SEL消息发送给对象指针：[p1 performSelector: s1];调用对象的方法，将SEL数据发送给对象。
----
点语法
- OC中也可以用点语法访问对象的属性，但是与java、C#完全不一样，使用点语法来访问对象的属性。
- 语法：对象名.去掉下划线的属性名。
- 点语法的原理： 点语法在编译器编译的时候，其实会将点语法再转化为调用setter、getter的代码。