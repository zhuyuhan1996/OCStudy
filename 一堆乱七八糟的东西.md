IBOutlet是一个对象属性，用于引用另一个对象，是通过interface Builder来记录的，记录在nib被加载时会被重新建立，在包含IBOutlet声明的对象与引用对象之间建立连接。

IBOutlet会占用内存，如果一个View集合包含了很多view，处于内存考虑，其中一种做法是可以通过tag来辨别不同的view，或者直接代码实例化view并建立引用，可以避免IBOutlet的过度使用。

IBAction是target-action设计模式里的概念，用于一个对象在触发某种事件时，通过发送特定的动作信息给目标对象，来实现彼此联系的目的。

getter和setter方法
getter和setter方法一定是对象方法，setter方法一定没有返回值，set开头并且set后面跟上需要设置的成员变量的名称，并且参数类型和需要设置的成员变量一致。

getter方法一定有返回值，并且返回值类型就是获取的成员变量的类型。

可以有效的屏蔽内部实现的细节，仅仅对外提供公共的接口和方法，保证数据的安全性。

平常在项目中使用的@property系统会自动给我们生成一个_开头的成员变量，是一个私有的成员变量。

id是一个数据类型，并且是一个动态数据类型，因此可以用来定义变量，作为函数的参数，作为函数的返回值。

通过动态数据类型访问了不属于动态数据类型的属性和方法，编译不会报错。

NSObject *是一个静态数据类型。

静态数据类型定义变量，不能调用子类特有的方法，动态数据类型可以调用子类特有的方法，可以调用私有方法。但是可能调用到不属于自己的方法，编译又不会报错，可能运行错误。

instancetype == id == 万能指针，instancetype可以在编译的时候，判断对象的真实类型。instancetype只能用作返回值。

自定义的构造方法，返回值尽量使用instancetype，不要使用id。

类工厂方法
就是用于快速创建对象的方法，主要用于给对象分配存储空间和初始化。

类本质也是一个对象，这个对象会在类第一次被使用的时候创建，只要有了类对象，将来就可以通过类对象创建实例对象，实例对象有一个isa指针，指向创建自己的类对象。

SEL类型代表方法的签名，在类对象的方法列表中存储着该签名和方法代码的对应关系，每个类的方法，都有一个与之对应的SEL类型的对象，根据一个SEL对象就可以找到方法的地址，进而调用方法。

只有OC对象才需要进行内存管理，OC对象放在堆中，非OC对象一般存放在栈里面，栈内存会被系统自动释放。

iOS的ARC和java中的垃圾回收机制不太一样，java中的垃圾回收是系统回收的，而OC中的ARC是编译器处理的。ARC的判断原则是只要还有一个强指针变量指向对象，对象就会保持在内存中，默认情况下所有指针都是强指针。

@class 作用是可以简单的引用一个类，仅仅告诉编译器，这是一个类，并不会包含这个类的所有内容，如果在.h中用@class，在.m中用import，那么如果一个文件发生了变化，只有和这个文件有直接关系的那个文件才会重新拷贝。

@class仅仅告诉编译器，他后面的名称是一个类，不会做任何拷贝操作，所以并不知道这个类中有哪些属性和方法。

调用autorelease，可以创建一个autoreleasepool,会对池子里的所有对象做一次release操作，好处在于不用关心对象的释放时间，不用再关心什么时候调用release。

不要在自动释放池中使用比较消耗内存的对象，占用内存比较大的对象；尽量不要在自动释放池中使用循环，特别是循环次数非常多，并且还非常占用内存；解决创建多个对象占用内存的问题。

如果存在多个自动释放池的时候，自动释放池是以栈的形式存储的。

Category
是OC特有的语法，可以在不修改原来类的基础上，为这个类扩充一些方法。

1.分类是用于给原有类的方法的,他只能添加方法,不能添加属性(成员变量)
2.分类中的@property,只会生成setter/getter方法的声明,不会生成实现以及私有的所有变量,
2.1 分类可以访问原来类中的成员变量
3. 注意:如果分类中和原有类同名的方法,会调用 分类的方法 
3.1如果多个分类中有同名的方法，会执行最后一个编译分类的方法

NSValue是NSNumber的子类，NSNumber可以包装数字类型，NSValue可以包装任意值，使用NSValue包装自定义的结构体，接受一个指针，传递需要包装的结构体的变量。
从NSValue取出自定义的结构体变量，需要传递指针的地址。